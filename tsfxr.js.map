{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 60503a6d680c93844398","webpack:///./src/index.ts","webpack:///./src/descriptor.ts","webpack:///./src/extend.ts","webpack:///./src/synth.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;;;;;;ACtCA;AACA,gBAAe;AACf;AACA;AACA,qBAAoB,uBAAuB;AAC3C;AACA;AACA,oBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"tsfxr.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tsfxr\"] = factory();\n\telse\n\t\troot[\"tsfxr\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 60503a6d680c93844398\n **/","\"use strict\";\nvar descriptor_1 = require('./descriptor');\nexports.Shape = descriptor_1.Shape;\nexports.makeDescriptor = descriptor_1.makeDescriptor;\nvar synth_1 = require('./synth');\nexports.synthesizeSamples = synth_1.default;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.ts\n ** module id = 0\n ** module chunks = 0\n **/","\"use strict\";\nvar extend_1 = require('./extend');\n(function (Shape) {\n    Shape[Shape[\"Square\"] = 0] = \"Square\";\n    Shape[Shape[\"Sawtooth\"] = 1] = \"Sawtooth\";\n    Shape[Shape[\"Sine\"] = 2] = \"Sine\";\n    Shape[Shape[\"Noise\"] = 3] = \"Noise\";\n})(exports.Shape || (exports.Shape = {}));\nvar Shape = exports.Shape;\nfunction makeDescriptor(params) {\n    return extend_1[\"default\"]({\n        wave_type: Shape.Square,\n        p_base_freq: 0.3,\n        p_freq_limit: 0.0,\n        p_freq_ramp: 0.0,\n        p_freq_dramp: 0.0,\n        p_duty: 0.0,\n        p_duty_ramp: 0.0,\n        p_vib_strength: 0.0,\n        p_vib_speed: 0.0,\n        p_vib_delay: 0.0,\n        p_env_attack: 0.0,\n        p_env_sustain: 0.3,\n        p_env_decay: 0.4,\n        p_env_punch: 0.0,\n        p_lpf_resonance: 0.0,\n        p_lpf_freq: 1.0,\n        p_lpf_ramp: 0.0,\n        p_hpf_freq: 0.0,\n        p_hpf_ramp: 0.0,\n        p_pha_offset: 0.0,\n        p_pha_ramp: 0.0,\n        p_repeat_speed: 0.0,\n        p_arp_speed: 0.0,\n        p_arp_mod: 0.0,\n        sound_vol: 0.25\n    }, params);\n}\nexports.makeDescriptor = makeDescriptor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/descriptor.ts\n ** module id = 1\n ** module chunks = 0\n **/","\"use strict\";\nvar hasOwn = {}.hasOwnProperty;\nfunction extend(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; ++i) {\n        var src = sources[i];\n        if (src) {\n            for (var key in src) {\n                if (hasOwn.call(src, key)) {\n                    target[key] = src[key];\n                }\n            }\n        }\n    }\n    return target;\n}\nexports.__esModule = true;\nexports[\"default\"] = extend;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/extend.ts\n ** module id = 2\n ** module chunks = 0\n **/","\"use strict\";\nvar descriptor_1 = require('./descriptor');\nfunction synthesizeSamples(desc) {\n    var phase = 0;\n    var fperiod = 0;\n    var fmaxperiod = 0;\n    var fslide = 0;\n    var fdslide = 0;\n    var period = 0;\n    var square_duty = 0;\n    var square_slide = 0;\n    // reset filter\n    var fltp = 0.0;\n    var fltdp = 0.0;\n    var fltw = Math.pow(desc.p_lpf_freq, 3.0) * 0.1;\n    var fltw_d = 1.0 + desc.p_lpf_ramp * 0.0001;\n    var fltdmp = 5.0 / (1.0 + Math.pow(desc.p_lpf_resonance, 2.0) * 20.0) * (0.01 + fltw);\n    if (fltdmp > 0.8)\n        fltdmp = 0.8;\n    var fltphp = 0.0;\n    var flthp = Math.pow(desc.p_hpf_freq, 2.0) * 0.1;\n    var flthp_d = 1.0 + desc.p_hpf_ramp * 0.0003;\n    // reset vibrato\n    var vib_phase = 0.0;\n    var vib_speed = Math.pow(desc.p_vib_speed, 2.0) * 0.01;\n    var vib_amp = desc.p_vib_strength * 0.5;\n    // reset envelope\n    var env_vol = 0.0;\n    var env_stage = 0;\n    var env_time = 0;\n    var env_length = [\n        Math.round(desc.p_env_attack * desc.p_env_attack * 100000.0),\n        Math.round(desc.p_env_sustain * desc.p_env_sustain * 100000.0),\n        Math.round(desc.p_env_decay * desc.p_env_decay * 100000.0)\n    ];\n    var fphase = Math.pow(desc.p_pha_offset, 2.0) * 1020.0;\n    if (desc.p_pha_offset < 0.0)\n        fphase = -fphase;\n    var fdphase = Math.pow(desc.p_pha_ramp, 2.0) * 1.0;\n    if (desc.p_pha_ramp < 0.0)\n        fdphase = -fdphase;\n    var iphase = Math.abs(Math.round(fphase));\n    var ipp = 0;\n    var phaser_buffer = [];\n    for (var i = 0; i < 1024; i++) {\n        phaser_buffer.push(0.0);\n    }\n    var noise_buffer = [];\n    for (var i = 0; i < 32; i++) {\n        noise_buffer.push(Math.random() * 2.0 - 1.0);\n    }\n    var rep_time = 0;\n    var rep_limit = Math.round(Math.pow(1.0 - desc.p_repeat_speed, 2.0) * 20000 + 32);\n    if (desc.p_repeat_speed === 0.0) {\n        rep_limit = 0;\n    }\n    var arp_time = 0;\n    var arp_limit = 0;\n    var arp_mod = 0.0;\n    function restart() {\n        fperiod = 100.0 / (desc.p_base_freq * desc.p_base_freq + 0.001);\n        period = Math.round(fperiod);\n        fmaxperiod = 100.0 / (desc.p_freq_limit * desc.p_freq_limit + 0.001);\n        fslide = 1.0 - Math.pow(desc.p_freq_ramp, 3.0) * 0.01;\n        fdslide = -Math.pow(desc.p_freq_dramp, 3.0) * 0.000001;\n        square_duty = 0.5 - desc.p_duty * 0.5;\n        square_slide = -desc.p_duty_ramp * 0.00005;\n        if (desc.p_arp_mod >= 0.0) {\n            arp_mod = 1.0 - Math.pow(desc.p_arp_mod, 2.0) * 0.9;\n        }\n        else {\n            arp_mod = 1.0 + Math.pow(desc.p_arp_mod, 2.0) * 10.0;\n        }\n        arp_time = 0;\n        arp_limit = Math.round(Math.pow(1.0 - desc.p_arp_speed, 2.0) * 20000 + 32);\n        if (desc.p_arp_speed === 1.0) {\n            arp_limit = 0;\n        }\n    }\n    restart();\n    var synthesizing = true, samples = [];\n    while (synthesizing) {\n        rep_time++;\n        if (rep_limit !== 0 && rep_time >= rep_limit) {\n            rep_time = 0;\n            restart();\n        }\n        // frequency envelopes / arpeggios\n        arp_time++;\n        if (arp_limit !== 0 && arp_time >= arp_limit) {\n            arp_limit = 0;\n            fperiod *= arp_mod;\n        }\n        fslide += fdslide;\n        fperiod *= fslide;\n        if (fperiod > fmaxperiod) {\n            fperiod = fmaxperiod;\n            if (desc.p_freq_limit > 0.0) {\n                synthesizing = false;\n            }\n        }\n        var rfperiod = fperiod;\n        if (vib_amp > 0.0) {\n            vib_phase += vib_speed;\n            rfperiod = fperiod * (1.0 + Math.sin(vib_phase) * vib_amp);\n        }\n        period = Math.round(rfperiod);\n        if (period < 8)\n            period = 8;\n        square_duty += square_slide;\n        if (square_duty < 0.0)\n            square_duty = 0.0;\n        if (square_duty > 0.5)\n            square_duty = 0.5;\n        // volume envelope\n        env_time++;\n        if (env_time > env_length[env_stage]) {\n            env_time = 0;\n            env_stage++;\n            if (env_stage === 3) {\n                synthesizing = false;\n            }\n        }\n        if (env_stage === 0) {\n            env_vol = env_time / env_length[0];\n        }\n        if (env_stage === 1) {\n            env_vol = 1.0 + Math.pow(1.0 - env_time / env_length[1], 1.0) * 2.0 * desc.p_env_punch;\n        }\n        if (env_stage === 2) {\n            env_vol = 1.0 - env_time / env_length[2];\n        }\n        // phaser step\n        fphase += fdphase;\n        iphase = Math.abs(Math.round(fphase));\n        if (iphase > 1023)\n            iphase = 1023;\n        if (flthp_d !== 0.0) {\n            flthp *= flthp_d;\n            if (flthp < 0.00001)\n                flthp = 0.00001;\n            if (flthp > 0.1)\n                flthp = 0.1;\n        }\n        var ssample = 0.0;\n        for (var si = 0; si < 8; si++) {\n            var sample = 0.0;\n            phase++;\n            if (phase >= period) {\n                //\t\t\t\tphase = 0;\n                phase %= period;\n                if (desc.wave_type === descriptor_1.Shape.Noise) {\n                    for (var i = 0; i < 32; i++) {\n                        noise_buffer[i] = Math.random() * 2.0 - 1.0;\n                    }\n                }\n            }\n            // base waveform\n            var fp = phase / period;\n            switch (desc.wave_type) {\n                case descriptor_1.Shape.Square:\n                    sample = (fp < square_duty) ? 0.5 : -0.5;\n                    break;\n                case descriptor_1.Shape.Sawtooth:\n                    sample = 1.0 - fp * 2;\n                    break;\n                case descriptor_1.Shape.Sine:\n                    sample = Math.sin(fp * 2 * Math.PI);\n                    break;\n                case descriptor_1.Shape.Noise:\n                    sample = noise_buffer[Math.floor(phase * 32 / period)];\n                    break;\n            }\n            // lp filter\n            var pp = fltp;\n            fltw *= fltw_d;\n            if (fltw < 0.0)\n                fltw = 0.0;\n            if (fltw > 0.1)\n                fltw = 0.1;\n            if (desc.p_lpf_freq !== 1.0) {\n                fltdp += (sample - fltp) * fltw;\n                fltdp -= fltdp * fltdmp;\n            }\n            else {\n                fltp = sample;\n                fltdp = 0.0;\n            }\n            fltp += fltdp;\n            // hp filter\n            fltphp += fltp - pp;\n            fltphp -= fltphp * flthp;\n            sample = fltphp;\n            // phaser\n            phaser_buffer[ipp & 1023] = sample;\n            sample += phaser_buffer[(ipp - iphase + 1024) & 1023];\n            ipp = (ipp + 1) & 1023;\n            // final accumulation and envelope application\n            ssample += sample * env_vol;\n        }\n        ssample = ssample / 8 * 2.0 * desc.sound_vol;\n        if (ssample > 1.0)\n            ssample = 1.0;\n        if (ssample < -1.0)\n            ssample = -1.0;\n        samples.push(ssample);\n    }\n    return samples;\n}\nexports.__esModule = true;\nexports[\"default\"] = synthesizeSamples;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/synth.ts\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}